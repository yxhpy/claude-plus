---
name: ui-optimizer
description: 当用户询问性能优化、代码改进或提到界面卡顿、加载慢等问题时自动调用。专注于前端性能和用户体验优化。
---

# 自动 UI 优化技能

当 Claude 检测到用户需要优化前端代码或改善性能时，自动调用此技能。

## 触发场景

- 用户说"这个页面加载很慢"
- 用户请求"优化这个组件的性能"
- 用户提到"如何减少包体积"
- 用户询问"界面有点卡顿"
- 用户描述性能问题

## 执行流程

1. **诊断问题**
   - 使用 Read 工具读取目标代码
   - 分析代码结构
   - 识别性能瓶颈
   - 检查常见问题（重复渲染、大包体积、未优化的资源）

2. **使用 Gemini CLI 进行优化分析**

   构建优化提示词并调用 gemini CLI：

   ```bash
   gemini --yolo -p "作为资深前端性能优化专家，分析以下代码并提供优化建议：

   [代码内容]

   请从以下角度分析：
   - 性能优化: 代码分割、懒加载、memo化、虚拟滚动、防抖节流
   - 包体积优化: Tree-shaking、动态导入、依赖优化
   - 渲染优化: 减少重复渲染、优化 key、Web Workers、图片优化
   - 用户体验: 骨架屏、加载状态、错误边界、平滑过渡

   对每个问题提供：
   1. 问题描述和影响
   2. 优化前后的代码对比
   3. 预期收益（性能提升、体积减少等）
   4. 实施优先级（高/中/低）"
   ```

3. **一次性输出优化方案**
   - 直接显示完整的优化分析
   - 提供优化后的代码
   - 说明预期收益
   - 给出实施步骤

## 示例对话

**用户**: "这个数据表格组件渲染 1000 行数据时很卡"

**Claude**: 我来分析并优化这个数据表格的性能。

[使用 Read 工具读取代码]
[使用 gemini CLI 进行分析]

⚡ 性能优化方案：

🔍 问题诊断：
- 一次性渲染 1000 个 DOM 节点导致卡顿
- 未使用虚拟滚动
- 每行都在重复渲染

💡 优化建议：

1. **实施虚拟滚动** (优先级：高)
   - 只渲染可见区域的行
   - 预期性能提升：90%+

2. **使用 React.memo**
   - 防止不必要的重渲染
   - 预期性能提升：30%

3. **优化数据结构**
   - 使用 Map 代替数组查找
   - 预期性能提升：20%

[显示优化代码...]

📈 预期效果：
- 初始渲染时间：从 2000ms 降至 200ms
- 滚动帧率：从 15fps 提升至 60fps
- 内存占用：减少 70%

## 优势

- ✅ 使用官方 Gemini CLI 工具
- ✅ 一次性完成优化分析，无重复验证
- ✅ 更快的响应速度
- ✅ 更可靠的执行
